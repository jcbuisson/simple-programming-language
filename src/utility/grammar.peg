
ProgramEx
  = _ instructions:(LabeledInstruction _)*
  { return instructions.map(function(e) { return e[0]; }); }

LabeledInstruction
  = label:Label _ ":" _ instruction:Instruction
  { return { 'label': label, 'instruction': instruction, 'line': location().start.line - 1 }; }
  / instruction:Instruction
  { return { 'label': null, 'instruction': instruction, 'line': location().start.line - 1 }; }
  
Instruction
  = "stop"
  { return { 'action': 'stop' }; }
  / "compare" _ expr1:Expression _ "to" _ expr2:Expression
  { return { 'action': 'compare', 'expr1': expr1, 'expr2': expr2 }; }
  / "go" _ label:Label _ "if" _ cond:Condition
  { return { 'action': 'go', 'target': label, 'condition': cond }; }
  / "go" _ label:Label
  { return { 'action': 'branch', 'target': label, 'condition': true }; }
  / expr:Expression _ "->" _ dest:MemoryLocation
  { return { 'action': 'copy', 'expr': expr, 'dest': dest, }; }

Label
  = char0:[a-zA-Z_] chars:[a-zA-Z0-9_]*
  { return (char0 + chars.join("")); }

Condition
  = "equal" / "greater" / "greater_or_equal" / "smaller" / "smaller_or_equal"
    
MemoryLocation
  = type:LocationType _ "[" _ index:Integer _ "]"
  { return { 'type': type, 'index': index, }; }

LocationType
  = "data" { return 'data'; }
  / "d" { return 'data'; }
  / "stack" { return 'stack'; }
  / "s" { return 'stack'; }
  / "input" { return 'input'; }
  / "in" { return 'input'; }
  / "output" { return 'output'; }
  / "out" { return 'output'; }
  
Expression
  = head:Term tail:(_ ("+" / "-") _ Term)*
  { return [head].concat(tail.map(function(e) { return [e[1],e[3]];} )); }
  
ExpressionZ
  = head:Term tail:ExpressionTail+
  { return { 'head': head, 'tail': tail } }
  / term:Term
  { return term; }
  
ExpressionTail
  = _ op:("+" / "-") _ term:Term
  { return { 'op': op, 'term': term }; }
  
Term
  = head:Factor tail:(_ ("*" / "/") _ Factor)*
  { return [head].concat(tail.map(function(e) { return [e[1],e[3]];} )); }

Factor
  = "(" _ expr:Expression _ ")"
  { return expr; }
  / int:Integer
  { return int; }
  / memloc:MemoryLocation
  { return memloc; }

Integer "integer"
  = [0-9]+ { return parseInt(text(), 10); }

_ "whitespace"
  = ( whiteSpace / lineTerminator / enclosedComment / lineComment )*
     { return []; }

whiteSpace 
  = [\t\v\f \u00A0\uFEFF] 

lineTerminator 
  = [\n\r] 

enclosedComment 
  = "/*" (!"*/" anyCharacter)* "*/" 

lineComment 
  = "//" (!lineTerminator anyCharacter)* 

anyCharacter 
  = . 
